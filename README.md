定义一个字符数组encrypt来表示密文集，即26个英文字母对应的加密字符；
定义一个字符数组ciphertext来表示用户输入的密文；
定义一个整型数组index来记录用户输入的密文的ASCII码值；
设置一个整型变量pos来记录用户输入的密文对应密文集encrypt中的位置（0~25）。

由用户输入密文，并对这个密文进行判断：若输入的密文不是26个英文字母，则要求用户重新输入，如果输入正确就执行：
while循环遍历这个密文，若密文为空，结束循环；若密文不为空，执行下面的判断语句：
如果密文为空格，则打印空格；
如果密文输入为小写的英文字母，则先转化为大写英文字母（密文集默认为大写英文字母），index数组记录用户输入该密文的ASCII码值，再遍历密文集encrypt，判断ASCII码值与index数组中记录的ASCII码值是否相等，若相等，pos记录下这个相等的ASCII码值在密文集encrypt的位置，跳出for循环，函数对应关系wei为：f=pos+65，以字符形式输出f不等则继续判断下一个值；
如果密文输入为大写的英文字母，则不用转化，index数组记录用户输入该密文的ASCII码值，再遍历密文集encrypt，判断ASCII码值与index数组中记录的ASCII码值是否相等，若相等，pos记录下这个相等的ASCII码值在密文集encrypt的位置，跳出for循环，函数对应关系wei为：f=pos+65，以字符形式输出f，不等则继续判断下一个值；

转化的离散数学问题：
由题可知：需要求给定密文明文。由题目的字符对应关系可知，这可以转换为一个一对一的函数来进行求解。
设集合A={x|0=<x<=25，x∈Z*}，密文集合B={DESTINYABCFGHJKLMOPQRUVWXZ}，明文集合C={ABCDEFGHIJKLMNOPQRSTUVWXYZ}，集合D={y|65=<y<=90，y∈Z*}。
所以存在函数关系:
f：A->B，f(0)=D，f(1)=E，f(2)=S，...，f(24)=X，f(25)=Z，即f(i)=b(i∈A，b∈B)。
g：B->C，g(D)=A，g(E)=B，g(S)=C，...，g(X)=Y，g(Z)=Z，即g(b)=c(b∈B，c∈C)。
h：C->D，h(A)=65，h(B)=66，h(C)=67，...，h(Y)=89，h(Z)=90，即h(c)=d(c∈C，d∈D)。
则密文转换为明文的解密函数为：
得到对应明文的ASCII码值：fºgºh=i+65，这个复合运算属于A到D的函数。
再进行h的逆运算得到D到C的函数关系，就得到所求的明文。
在实际编程中，密文集合A是使用字符数组表示，元素对应的数组序号i，与明文集合B的ASCII码值具有对应关系，即为f(i)=i+65  f(i)为集合B元素对应的ASCII码值。
